<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Mini Data-Binding Demo</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 2rem; }
    /*ul { list-style: none; padding: 0; }
    li { margin: 0.5rem 0; }*/
    button { margin-top: 1rem; padding: 0.5rem 1rem; }
  </style>
</head>
<body>

<div id="headline">
    <input id="name" value="{{ name }}">
    <h1 style="background-color: {{ headlineBackground }};">Willkommen, {{ name }}!</h1>
    <p>Hallo {{ name }}</p>

  <!-- IF-Direktive -->
  <if test="showCondTitle">
    <h1 style="background-color: {{ headlineBackground }};">bedingtes Willkommen, {{ name }}!</h1>

    <if test="showCondTitle2">
      <h2>bedingtes Willkommen, {{ name }}!</h2>
    </if>
  </if>
</div>

<div id="main">
  <!-- EACH-Direktive -->
  <!--<ul>
    <each of="items" as="item">
      <li style="background-color: {{ liBackground }}">{{ item.name }} ({{ item.age }} Jahre)</li>
      <ul>
        <div>TEST</div>
        <each of="item.children" as="child">
            <li>{{ child.name }}</li>
        </each>
      </ul>
    </each>
  </ul>-->

  <recursive-template name="rec1">
    <ul>
      <each of="items" as="item" deep-structure="item.children">
        <li style="background-color: {{ liBackground }}">{{ item.name }} ({{ item.age }} Jahre)</li>
        <ul>
          <div>TEST</div>
          <each of="item.children" as="child">
              <li>{{ child.name }}</li>
          </each>
        </ul>
      </each>
    </ul>
  </recursive-template>

  <button id="push">Push</button>
  <button id="pop">Pop</button>

  <button id="toggle">Titel umschalten</button>
</div>

<script>

  // -----------------------------
  // Mini-Reaktivität
  // -----------------------------
  function reactive(obj, callback) {
    return new Proxy(obj, {
      get(target, prop) {
        const value = target[prop];
        if (value && typeof value === 'object') return reactive(value, callback);
        return value;
      },
      set(target, prop, value) {
        target[prop] = value;
        callback();
        return true;
      }
    });
  }

  function getDirectInnerText(el) {
    return Array.from(el.childNodes)
      .filter(node => node.nodeType === Node.TEXT_NODE)
      .map(node => node.textContent.trim())
      .join("");
  }


  // -----------------------------
  // Renderer für <if> und <each>
  // -----------------------------

// --- Hilfsfunktionen ---

function interpolateText(template, model, context) {
  return template.replace(/\{\{\s*([\w.-]+)\s*\}\}/g, (_, key) => {
    const value = resolvePath(key, model, context);
    return value !== undefined ? value : "";
  });
}

function interpolateAttributes(node, model, context) {
  for (const attr of Array.from(node.attributes)) {
    if (!attr.name.match(/^data-template/)) {
      const key = "template" + attr.name;
      const tplValue = node.dataset[key] || attr.value;
      if (/\{\{.*?\}\}/.test(tplValue)) {
        node.dataset[key] = tplValue; // Original speichern
        node.setAttribute(attr.name, interpolateText(tplValue, model, context));
      }
    }
  }
}

function applyInterpolations(node, model, context) {
  const templateText = node.dataset.templateInnerText || getDirectInnerText(node);
  if (templateText && /\{\{.*?\}\}/.test(templateText)) {
    node.dataset.templateInnerText = templateText;
    node.innerText = interpolateText(templateText, model, context);
  }
  interpolateAttributes(node, model, context);
}

// --- Template-Expansion ---

function expandEachTag(eachElement, model, context = {}) {
  const arrayName = eachElement.getAttribute("of"); // z.B. "items" oder "item.children"
  const asName = eachElement.getAttribute("as") || "item";

  const items = resolvePath(arrayName, model, context) || [];
  return items.flatMap(item => {
    const newContext = { ...context, [asName]: item };
    return expandChildren(eachElement, model, newContext);
  });
}

function expandTemplate(templateElement, model, context = {}) {
  if (templateElement.tagName === "EACH") {
    return expandEachTag(templateElement, model, context);
  }

  const newEl = document.createElement(templateElement.tagName);
  newEl.dataset.cloned = "true";

  // Text + Attribute interpolieren
  const directInnerText = getDirectInnerText(templateElement);
  if (directInnerText) {
    newEl.innerText = directInnerText; // erstmal setzen
    newEl.dataset.templateInnerText = directInnerText; // Original sichern
  }

  // Attribute kopieren
  for (const attr of Array.from(templateElement.attributes)) {
    newEl.setAttribute(attr.name, attr.value);
  }

  // Text + Attribute interpolieren
  applyInterpolations(newEl, model, context);

  // Kinder expandieren
  const children = expandChildren(templateElement, model, context);
  children.forEach(c => newEl.appendChild(c));

  return [newEl];
}

function expandChildren(parentTemplate, model, context = {}) {
  const childTemplates = parentTemplate.querySelectorAll(":scope > *");
  return Array.from(childTemplates).flatMap(child =>
    expandTemplate(child, model, context)
  );
}

// --- Rendering ---

function render(root, model, context = {}) {
  const rootChildren = root.querySelectorAll(":scope > *");

  rootChildren.forEach(child => {
    const parent = child.parentNode;

    switch (child.tagName) {
      case "EACH": {
        parent.querySelectorAll('[data-cloned="true"]').forEach(oCE => oCE.remove());
        const expanded = expandEachTag(child, model, context);
        expanded.forEach(el => parent.insertBefore(el, child));
        child.style.display = "none";
        break;
      }

      case "IF": {
        const testExpr = child.getAttribute("test");
        const value = resolvePath(testExpr, model, context);

        // Node-Templates einmalig speichern
        if (!child._ifTemplateNodes) {
          child._ifTemplateNodes = Array.from(child.childNodes).map(n => n.cloneNode(true));
        }

        // Aktuelle Kinder entfernen
        while (child.firstChild) child.removeChild(child.firstChild);

        if (value) {
          // Node-Templates wieder einfügen (Klon)
          child._ifTemplateNodes.forEach(n => child.appendChild(n.cloneNode(true)));

          // Rekursiv rendern
          render(child, model, context);
        }
        break;
      }

      default: {
        applyInterpolations(child, model, context);
        render(child, model, context); // rekursiv
      }
    }
  });
}

// Hilfsfunktion: löst "item.children" oder "modelKey.subKey" im Kontext/Model auf
function resolvePath(path, model, context) {
  const parts = path.split('.');
  let current = context.hasOwnProperty(parts[0]) ? context[parts[0]] : model[parts[0]];

  for (let i = 1; i < parts.length; i++) {
    if (current == null) return undefined;
    current = current[parts[i]];
  }
  return current;
}

  const headlineModel = reactive({
    showCondTitle: true,
    showCondTitle2: true,
    headlineBackground: 'yellow',
    name: 'Tobias'
  }, () => render(document.getElementById('headline'), headlineModel))

  const mainModel = reactive({
    items: [
      { name: 'Alice', age: 25, children: [ { name: 'Alice_1', age: 10, children: [ { name: 'Alice_1_1', age: 5 } ] } ] },
      { name: 'Bob', age: 30 },
      { name: 'Charlie', age: 20, children: [ { name: 'Charlie_1', age: 5 } ] }
    ],
    liBackground: 'yellow'
  }, () => render(document.getElementById('main'), mainModel))

  // -----------------------------
  // Initiales Rendering
  // -----------------------------
  render(document.getElementById('headline'), headlineModel)
  render(document.getElementById('main'), mainModel)

  // -----------------------------
  // Interaktion
  // -----------------------------

  document.getElementById('toggle').addEventListener('click', () => {
    headlineModel.showCondTitle = !headlineModel.showCondTitle;
  });

  document.getElementById('name').addEventListener('input', e => {
    headlineModel.name = e.target.value;
    console.log(headlineModel.name)
  });


  document.getElementById('push').addEventListener('click', () => {
    mainModel.items.push({'name': 'Tobias', 'age': 30})
  });

  document.getElementById('pop').addEventListener('click', () => {
    mainModel.items.pop()
  });
</script>

</body>
</html>
